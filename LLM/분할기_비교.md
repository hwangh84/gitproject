# RAG 시스템 텍스트 분할기 (Text Splitter) 상세 비교

RAG(검색 증강 생성) 시스템의 성능은 문서를 어떻게 자르느냐(Chunking)에 따라 크게 달라집니다. 아래 표는 LangChain에서 주로 사용되는 다양한 텍스트 분할기들의 특징, 장단점, 그리고 추천 사용 사례를 상세히 비교한 것입니다.

## 텍스트 분할기 비교표

| 분할기 (Splitter) | 작동 방식 (Mechanism) | 장점 (Pros) | 단점 (Cons) | 추천 사용 사례 (Best Use Case) |
| :--- | :--- | :--- | :--- | :--- |
| **RecursiveCharacterTextSplitter**<br>(재귀적 문자 분할기) | `separators` 리스트의 우선순위(단락 `\n\n` > 줄 `\n` > 공백 ` ` > 문자 ` `)에 따라 재귀적으로 분할을 시도합니다. | 문맥(Context)을 가장 잘 보존합니다. 문장이 중간에 잘리지 않도록 최대한 노력하며, 의미적으로 연관된 텍스트를 함께 묶습니다. | 설정이 다소 복잡할 수 있으며, 구조가 없는 텍스트에는 큰 이점이 없을 수 있습니다. | **[가장 권장]** 일반적인 문서, 논문, 보고서 등 논리적 구조가 있는 대부분의 텍스트. |
| **CharacterTextSplitter**<br>(문자 분할기) | 단일 구분자(기본값: `\n\n`) 하나만을 기준으로 텍스트를 분할합니다. | 구현이 매우 간단하고 처리 속도가 빠릅니다. | 구분자가 하나뿐이라 청크 크기 제한에 걸리면 문맥 고려 없이 강제로 자를 수 있어 문맥 파괴 위험이 높습니다. | 구조가 매우 단순하거나, 특정 구분자로만 나누어도 충분한 간단한 텍스트. |
| **TokenTextSplitter**<br>(토큰 분할기) | 텍스트를 LLM이 처리하는 '토큰(Token)' 단위로 변환한 뒤, 토큰 개수에 맞춰 분할합니다. (예: `tiktoken`) | LLM의 Context Window(입력 제한)를 정확하게 맞출 수 있어 비용 관리와 오류 방지에 유리합니다. | 단어가 아닌 토큰 단위로 잘리므로, 문장이나 단어의 의미가 중간에 끊길 수 있습니다. (디코딩 시 깨질 수 있음) | 토큰 제한이 엄격한 모델을 사용하거나, 정확한 토큰 수 제어가 필요할 때. |
| **MarkdownHeaderTextSplitter**<br>(마크다운 헤더 분할기) | 마크다운의 헤더(`#`, `##`, `###`)를 기준으로 계층적으로 분할합니다. | 문서의 논리적 구조(챕터, 섹션)를 완벽하게 보존합니다. 검색 시 해당 섹션의 내용을 온전히 가져올 수 있습니다. | 마크다운(`md`) 형식이 아닌 일반 텍스트에는 사용할 수 없습니다. | 마크다운 문서, 노션(Notion) 내보내기 파일, 기술 문서, 위키 등 구조화된 문서. |
| **SemanticChunker**<br>(의미론적 청킹) | 텍스트의 의미(Embedding)를 분석하여, 주제나 내용이 바뀌는 지점을 찾아 분할합니다. | 물리적인 길이보다 '의미' 단위로 잘리기 때문에 검색 정확도와 답변 품질이 매우 높을 수 있습니다. | 임베딩 모델을 사용하므로 계산 비용이 들고 속도가 느립니다. 설정(임계값 등)이 까다로울 수 있습니다. | 고품질의 RAG 시스템, 내용의 흐름이 중요하거나 주제 전환이 뚜렷한 긴 글. |
| **KonlpyTextSplitter**<br>(한국어 형태소 분할기) | 한국어 형태소 분석기(KoNLPy)를 사용하여 문장이나 구 단위로 의미 있게 분할합니다. | 한국어의 언어적 특성(교착어)을 고려하여 분할하므로, 단순 문자 분할보다 문맥 보존에 유리할 수 있습니다. | KoNLPy 및 자바(JDK) 설치가 필요하며, 분석 속도가 상대적으로 느릴 수 있습니다. | 한국어 텍스트 처리에 특화된 정밀한 분할이 필요할 때. |

## 주요 매개변수 설명

모든 분할기에서 공통적으로 사용되는 중요한 매개변수들입니다.

*   **`chunk_size`**: 하나의 청크가 가질 수 있는 최대 크기입니다. (문자 수 또는 토큰 수)
    *   *너무 작으면*: 문맥을 파악하기 어렵습니다.
    *   *너무 크면*: LLM의 입력 제한을 넘거나, 검색 시 불필요한 정보가 섞일 수 있습니다.
*   **`chunk_overlap`**: 인접한 청크 간에 중복되는 구간의 크기입니다.
    *   *목적*: 청크가 나뉘는 경계선에 있는 중요한 문맥이 잘려나가는 것을 방지합니다. (보통 10~20% 정도 설정)
*   **`separators`**: 텍스트를 자르는 기준이 되는 문자열들의 리스트입니다. (RecursiveCharacterTextSplitter에서 중요)